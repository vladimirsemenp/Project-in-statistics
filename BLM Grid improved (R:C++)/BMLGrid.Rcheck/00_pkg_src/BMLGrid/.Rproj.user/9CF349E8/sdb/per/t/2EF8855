{
    "contents" : "library(Rcpp)\nlibrary(devtools)\nlibrary(roxygen2)\n\n###########################################################\n# crunBMLGrid and C routines\n###########################################################\n\n######################## version 1 ########################\n# version 1 is the version that performs the best\n\n# Rccp function to move cars right\ncppFunction('IntegerMatrix moveRightInC(IntegerMatrix m){\n            int r=m.nrow();\n            int c=m.ncol();\n            for(int i=0; i<r; i++){\n            for(int j=c-1; j>0; j--){\n            if(m(i,j)==0 & m(i,j-1)==1){\n            m(i,j)=1;\n            m(i,j-1)=4;\n            }else{\n            if(m(i,j)==4){m(i,j)=0;}\n            }\n            }\n            }\n            return m;\n            }')\n\n# Rccp function to move cars up\ncppFunction('IntegerMatrix moveUpInC(IntegerMatrix m){\n            int r=m.nrow();\n            int c=m.ncol();\n            for(int j=0; j<c; j++){\n            for(int i=r-1; i>0; i--){\n            if(m(i,j)==0 & m(i-1,j)==2){\n            m(i,j)=2;\n            m(i-1,j)=4;\n            }else{\n            if(m(i,j)==4){m(i,j)=0;}\n            }\n            }\n            }\n            return m;\n            }')\n\n# Rccp function to wrap in the horizontal direction\ncppFunction('IntegerMatrix wrapRightInC(IntegerMatrix m){\n            int r=m.nrow();\n            int c=m.ncol();       \n            for(int i=0; i<r; i++){\n            m(i,0)=m(i,c-2);\n            m(i,c-1)=m(i,1);\n            }\n            return m;\n            }')\n\n# Rccp function to wrap in the vertical direction\ncppFunction('IntegerMatrix wrapUpInC(IntegerMatrix m){\n            int r=m.nrow();\n            int c=m.ncol();       \n            for(int j=0; j<c; j++){\n            m(0,j)=m(r-2,j);\n            m(r-1,j)=m(1,j);\n            }\n            return m;\n            }')\n\n# main function to move cars using Rccp\ncrunBMLGrid=function(m,n=1){\n  r=nrow(m)\n  c=ncol(m)\n  m1=addTwo(m)\n  for(i in 1:n){\n    m1=moveRightInC(m1)\n    m1=wrapRightInC(m1)\n    m1=moveUpInC(m1)\n    m1=wrapUpInC(m1)\n  }\n  m[]=m1[1:r,1:c]\n  m\n}\n\n######################## version 2 ########################\n# I change moveRightInC in this version\n\n# Rccp function to move cars right version 2\ncppFunction('IntegerMatrix moveRightInCv2(IntegerMatrix m){\n            int r=m.nrow();\n            int c=m.ncol();\n            bool notMoved;\n            /* notMoved indicates whether a car on the previous step moved */\n            for(int i=0; i<r; i++){\n            notMoved=true;\n            for(int j=c-1; j>0; j--){\n            if( notMoved & (m(i,j)==0) & (m(i,j-1)==1) ){\n            m(i,j)=1;\n            m(i,j-1)=0;\n            notMoved=false;\n            }else{\n            notMoved=true;\n            }\n            }\n            }\n            return m;\n            }')\n\n# main function\ncrunBMLGridv2=function(m,n=1){\n  r=nrow(m)\n  c=ncol(m)\n  m1=addTwo(m)\n  for(i in 1:n){\n    m1=moveRightInCv2(m1)\n    m1=wrapRightInC(m1)\n    m1=moveUpInC(m1)\n    m1=wrapUpInC(m1)\n  }\n  m[]=m1[1:r,1:c]\n  m\n}\n\n######################## version 3 ########################\n# I replace wrapMatrixInC by a code in R \n\ncrunBMLGridv3=function(m,n=1){\n  r=nrow(m)\n  c=ncol(m)\n  m1=addTwo(m)\n  for(i in 1:n){\n    m1=moveRightInC(m1)\n    m1[,1]=m1[,c+1]\n    m1[,c+2]=m1[,2]\n    m1=moveUpInC(m1)\n    m1[1,]=m1[r+1,]\n    m1[r+2,]=m1[2,]\n  }\n  m[]=m1[1:r,1:c]\n  m\n}\n\n###########################################################\n# profiling\n###########################################################\n\n# first table \ng=createBMLGrid(0.2,r=1000,c=1000)\nRprof()\ng=crunBMLGrid(g,10000)\nRprof(NULL)\nsummaryRprof()\n\n#first plot\nv1=v2=v3=vector(,20)\nv1[]=v2[]=v3[]=0\nfor(j in 1:5){\nfor(i in 1:20){\n  g=createBMLGrid(i/21,r=500,c=500)\n  Rprof()\n  g1=crunBMLGrid(g,100)\n  Rprof(NULL)\n  v1[i]=summaryRprof()$sampling.time+v1[i]\n  Rprof()\n  g2=crunBMLGridv2(g,100)\n  Rprof(NULL)\n  v2[i]=summaryRprof()$sampling.time+v2[i]\n  Rprof()\n  g3=crunBMLGridv3(g,100)\n  Rprof(NULL)\n  v3[i]=summaryRprof()$sampling.time+v3[i]\n}\n}\nplot((1:20)/21,v1,main=\"time vs density\",\n     xlab=\"density\",ylab=\"time\",xlim=c(0,1),ylim=c(0.5,3),\n     pch=0)\npoints((1:20)/21,v2,pch=1)\npoints((1:20)/21,v3,pch=2)\nlegend(locator(1),c(\"Cv1\",\"Cv2\",\"Cv3\"),pch=c(0,1,2))\n\n# second plot\nv1=v2=vector(,12)\nv1[]=v2[]=0\nfor(i in 1:12){\n    g=createBMLGrid(0.2,r=50*i,c=50*i)\n    Rprof()\n    g1=runBMLGrid(g,30)\n    Rprof(NULL)\n    v1[i]=summaryRprof()$sampling.time\n    Rprof()\n    g2=crunBMLGrid(g,30)\n    Rprof(NULL)\n    v2[i]=summaryRprof()$sampling.time\n}\nplot(1:12*50,v1,main=\"time vs linear size\",\n     xlab=\"linear size\",ylab=\"time\",xlim=c(0,700),ylim=c(0,17),\n     pch=0)\npoints(1:12*50,v2*100,pch=1)\nlegend(locator(1),c(\"Rv2\",\"Cv1*100\"),pch=c(0,1))\n\n# third plot\nm=matrix(,20,5)\nm[]=0\nfor(j in 1:4){\nfor(i in 1:20){\n  g=createBMLGrid(0.2*j,r=50*i,c=50*i)\n  Rprof()\n  g1=crunBMLGrid(g,100)\n  Rprof(NULL)\n  m[i,j]=summaryRprof()$sampling.time\n  m[i,5]=50*i\n}\n}\n\npar(mfrow=c(2,2))\nfor(j in 1:4){\nplot(m[,5],m[,j],main=c(\"time vs linear size, density=\",\n     as.character(j*0.2)), xlab=\"linear size\",ylab=\"time\",xlim=c(0,1050),\n     ylim=c(0,1.4))\nfit=lm(m[,j]~m[,5]+I(m[,5]^2))\npoints(m[,5], fitted(fit)[order(m[,5])], type='l')\n}\n\n\n\n###########################################################\n# testing\n###########################################################\n\n# see the /test directory \n\nsetwd(\"~/Desktop/22\")\ninstall(\"BMLGrid\")\nlibrary(BMLGrid)\ncheck(\"BMLGrid\")\n?createBMLGrid\n?runBMLGrid\n?crunBMLGrid\n#tar(\"BMLGrid.tar.gz\", \"./BMLGrid\", compression = 'gzip', tar=\"tar\")\n\n###########################################################\n# old code from the assignment 2 \n###########################################################\n\n#create random matrix with entries 0, 1, 2 corresponding\n#to none, red, blue cars\n#cars of different color have the same number\ncreateG=function(rowN, colN, redNum, blueNum){\n  m=matrix(, rowN, colN);\n  size=length(m);\n  v=sample(1:size, redNum+blueNum, replace=FALSE);\n  u=sample(v, blueNum, replace=FALSE);\n  m[]=0; m[v]=1; m[u]=2;\n  m\n  #some assingments here are redundant but it doesn't\n  #affect performance\n}\n\n#adds two rows and two columns two a matrix\n#these new rows and columns repeat the first two\naddTwo=function(m){\n  m2=matrix(,nrow(m)+2,ncol(m)+2);\n  m2[1:nrow(m),1:ncol(m)]=m[,];\n  m2[1:2+nrow(m),]=m2[1:2,];\n  m2[,1:2+ncol(m)]=m2[,1:2];\n  m2\n  #rbind/cbind work worse here\n}\n\n#this function performs n move for red cars and n\n#for blue cars\n#m is a matrix with 0, 1, 2\n#that correspond to none, red, blue cars\nmoveN=function(m,n=1){\n  colN=ncol(m);\n  rowN=nrow(m);\n  m=addTwo(m)\n  m1=ifelse(m==1, TRUE, FALSE);\n  m2=ifelse(m==2, TRUE, FALSE);\n  #switch to Boolean matrices\n  m3=mR1=mR2=matrix(, nrow(m), ncol(m));\n  #preallocate\n  for(i in 1:n){\n    m3=m1 | m2;\n    m1=moveRight(m1, m3, mR1, mR2, colN);\n    m3=m1 | m2;\n    m2=moveUp(m2, m3, mR1, mR2, rowN)\n  };\n  m=ifelse(m1, 1, ifelse(m2, 2, 0));\n  m=m[1:(nrow(m)-2),1:(ncol(m)-2)];\n  #switch back\n  m\n}\n\n#right move\n#m1 is a Boolean matrix of red cars\n#m2 is a Boolean matrix of any cars\n#mR1, mR2 are preallocated matrices - we don't want\n#to create them inside a loop\n#N - number of columns\nmoveRight=function(m1, m2, mR1, mR2, N){\n  mR1[,2:(N+2)]=m1[,1:(N+1)];\n  mR2[,1:(N+1)]=m2[,2:(N+2)];\n  m1=ifelse(mR2, m1, FALSE) | ifelse(m2, FALSE, mR1);\n  m1[,1]=m1[,N+1]; m1[,N+2]=m1[,2];\n  m1\n}\n\n#move down in matrix, move up on plot\n#m1 is a Boolean matrix of blue cars\n#m2 is a Boolean matrix of any cars\n#mR1, mR2 are preallocated matrices - we don't want to create them \n#inside a loop\n#N - number of rows\nmoveUp=function(m1, m2, mR1, mR2, N){\n  mR1[2:(N+2),]=m1[1:(N+1),];\n  mR2[1:(N+1),]=m2[2:(N+2),];\n  m1=ifelse(mR2,m1,FALSE) | ifelse(m2,FALSE,mR1);\n  m1[1,]=m1[N+1,]; m1[N+2,]=m1[2,];\n  m1\n}\n#we could make moveUp just applying moveRight to \n#transpose matrices but it would make moveUp slower\n\n#create structures\ncreateBMLGrid=function(density, r=100, c=100, ncars){\n  if(missing(ncars)){\n    redN=blueN=as.integer(density*r*c*0.5);\n    m=createG(r, c, redN, blueN);\n    structure(m, class=c(\"BMLGrid\", class(m)))\n  }else{\n    if(missing(density)){\n      m=createG(r, c, ncars[1], ncars[2]);\n      structure(m, class=c(\"BMLGrid\", class(m)))\n    }else{\n      print(\"Can't specify both density and ncars!\")\n    }\n  }\n}\n\n#create structures\nrunBMLGrid=function(g, numSteps=100){\n  g=moveN(g, numSteps);\n  structure(g, class=c(\"BMLGrid\", class(g)))\n}\n\n#function to measure the number of cars that moved,\n#that were blocked, and the average\n#velocity in each iteration between\n#start time and end time\n#returns matrix of these measurements\nspeedBMLGrid=function(m, start=0, end=1){\n  m2=m;\n  w=matrix(, end-start, 8);\n  w[,8]=(start+1):end\n  redT=sum(ifelse(m==1, 1, 0));\n  blueT=sum(ifelse(m==2, 1, 0));\n  colnames(w)=c(\"Red speed\", \"Blue speed\", \"Red move\",\n                \"Blue move\", \"Red block\", \"Blue block\", \n                \"Total speed\", \"Step number\");\n  if(start!=0) { m=runBMLGrid(m,start) };\n  for(i in (start+1):end){\n    m2=runBMLGrid(m,1);\n    w[i-start,5:6]=c(sum(ifelse(m==1 & m2==1, 1, 0)),\n                     sum(ifelse(m==2 & m2==2, 1, 0)));\n    m=m2\n  };\n  w[,3]=redT-w[,5]; w[,4]=blueT-w[,6]; \n  w[,1]=w[,3]/redT; w[,2]=w[,4]/blueT; \n  w[,7]=(w[,3]+w[,4])/(redT+blueT);\n  w\n}\n\n#plot dependence between total speed at the iteration\n#iterationStep and the density\n#numberPoints specifies number of points on the plot\n#in the interval (densitystart, densityend)\nvectorDensitySpeed=function(numberPoints, densitystart,\n                            densityend, iterationStep){\n  dens=(densityend-densitystart)/(numberPoints+1);\n  v=vector(,numberPoints+5);\n  for(i in 1:numberPoints){\n    m=createBMLGrid(densitystart+dens*i);\n    w=speedBMLGrid(m,iterationStep,iterationStep+10);\n    v[i]=sum(w[,7])/10\n  };\n  for(i in numberPoints+1:5){\n    m=createBMLGrid((i-numberPoints)/6);\n    w=speedBMLGrid(m,iterationStep,iterationStep+10);\n    v[i]=sum(w[,7])/10\n  };\n  plot(c(densitystart+1:numberPoints * dens,1:5/6), v,\n       main=\"Speed vs Density\", \n       xlab=\"Density\", ylab=\"Speed\",);\n  v\n}\n\n#plot s3 classes\nplot.BMLGrid=function(x, submain=\"\"){\n  image(x,col=c(\"white\",\"red\",\"blue\"),xaxt= \"n\", yaxt= \"n\", main=c(\"BMLGrid\\n\",submain) );\n  arrows(0.05, 0.3, x1 = 0.95, y1 = 0.3, length = 0.7, col = \"blue\");\n  arrows(0.05, 0.7, x1 = 0.95, y1 = 0.7, length = 0.7, col = \"blue\");\n  arrows(0.7, 0.05, x1 = 0.7, y1 = 0.95, length = 0.7, col = \"red\");\n  arrows(0.7, 0.05, x1 = 0.7, y1 = 0.95, length = 0.7, col = \"red\")\n}\n\n#summary s3 classes\nsummary.BMLGrid=function(x){\n  l=list();\n  for(i in 1:7){\n    l[[i]]=speedBMLGrid(x,start=0,end=10)[1:10,i]\n  };\n  names(l)=c(\"Red_speed\", \"Blue_speed\", \"Red_move\",\n             \"Blue_move\", \"Red_block\", \"Blue_block\", \n             \"Total_speed\");\n  l\n}\n\n# #make plots for the report\n# v=vectorDensitySpeed(20,0.35,0.45,1800)\n# v1=createBMLGrid(0.3)\n# w1=speedBMLGrid(v1,end=800)\n# v2=createBMLGrid(0.5)\n# w2=speedBMLGrid(v2,end=800)\n# par(mfrow=c(1,2))\n# plot (c(0,800),c(0,1),type=\"n\",xlab=\"step number\",\n# ylab=\"speed\", main=\"Speed vs iteration \\n with density=0.3\") \n# lines(w1[,8],w1[,1],col=\"red\",lwd=2.5)\n# lines(w1[,8],w1[,2],col=\"blue\",lwd=2.5)\n# plot (c(0,800),c(0,1),type=\"n\",xlab=\"step number\",\n# ylab=\"speed\", main=\"Speed vs iteration \\n with density=0.5\")\n# lines(w2[,8],w2[,1],col=\"red\",lwd=2.5)\n# lines(w2[,8],w2[,2],col=\"blue\",lwd=2.5)\n# \n# #plot image\n#  g=createBMLGrid(0.2)\n#  g=runBMLGrid(g,1000)\n#  par(mfrow=c(1,2))\n#  plot(g,\"density=0.2\")\n#  g=createBMLGrid(0.5)\n#  g=runBMLGrid(g,1000)\n#  plot(g,\"density=0.5\")\n\n\n#now we compare this approach to a naive one\n#we write new functions that perform moves\n\nmoveNaiveR=function(m){\n  r=nrow(m);\n  c=ncol(m);\n  for(i in 1:r){\n    for(j in c:2){\n      if(m[i,j]==0 & m[i,j-1]==1){\n        m[i,j]=1;\n        m[i,j-1]=4\n      }\n    }\n  };\n  m=ifelse(m==4, 0, m);\n  m\n}\nmoveNaiveU=function(m){\n  r=nrow(m);\n  c=ncol(m);\n  for(j in 1:c){\n    for(i in r:2){\n      if(m[i,j]==0 && m[i-1,j]==2){\n        m[i,j]=2;\n        m[i-1,j]=4\n      }\n    }\n  };\n  m=ifelse(m==4, 0, m);\n  m\n}\n#we could use transpose\n#but it wouldn't be clear\nmoveNaive=function(m,n){\n  r=nrow(m);\n  c=ncol(m);\n  m1=addTwo(m)\n  for(i in 1:n){\n    m1=moveNaiveR(m1);\n    m1[,1]=m1[,c+1];\n    m1[,c+2]=m1[,2];\n    m1=moveNaiveU(m1);\n    m1[1,]=m1[r+1,];\n    m1[r+2,]=m1[2,]\n  };\n  m[]=m1[1:r,1:c];\n  m\n}",
    "created" : 1431930815678.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3064610522",
    "id" : "2EF8855",
    "lastKnownWriteTime" : 1431951264,
    "path" : "~/Desktop/Assignment 4/Assignment4.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}